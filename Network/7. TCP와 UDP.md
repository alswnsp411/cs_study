# TCP & UDP

## TCP 와 UDP 모두 프로토콜이다. 
![image](https://github.com/kksshh0612/cs_study/assets/81570533/3648f653-f062-4500-9c84-0df42e7cd1bb)<br>
TCP와 UDP는 전송계층에 해당하는 프로토콜로, 데이터 전송을 위해 포트 번호가 사용된다. 

🧹**프로토콜**이란? : 컴퓨터 내부 또는 컴퓨터 사이에 데이터를 교환하는 방식을 정의한 규칙이다. <br><br>

## TCP & UDP 의 등장 배경 
- IP의 한계 : IP(Internet Protocol)은 데이터를 패킷으로 감싸서 IP 주소를 통해 두 컴퓨터가 패킷을 주고 받는 프로토콜이다.<br>
![image](https://github.com/kksshh0612/cs_study/assets/81570533/4d691cfe-ea1e-4e59-99ff-1817ca1b52a9)
그런데, IP만을 이용한 통신에는 한계점이 있었다. 크게 두 가지가 있는데, <br>
1. **비신뢰성** : IP는 데이터 흐름에 관여하지 않고, 출발지 IP Address에서 목적지 IP Address가 패킷에 적혀있는 프로토콜이기 때문에
패킷이 **순서대로** 갔는지, 그리고 혹시 중간에 호스트가 강제로 종료되어 **유실**되진 않았는지 보장할 수 없다.<br>
2. **비연결성** : 패킷을 받을 상대 호스트가 연결 상태임을 확인하지 않는다. 따라서, 호스트가 강제 종료되어 있어도 패킷을 전송한다. <br><br>
▶️**이러한 한계를 극복하기 위하여 전송계층에서 TCP와 UDP 프로토콜을 추가 정의하였다.**

## TCP (Transmission Control Protocol)
- IP 패킷 전송을 제어하여 신뢰성을 보증함으로써 IP통신의 단점을 보완한 프로토콜이다.
- 보통 TCP/IP라 부르는데, IP 위에서 TCP가 동작하기 때문에 보통 그렇게 부르는 것이고, 둘은 별개의 프로토콜이다. <br>
IP에 따라 IP 주소를 찾고, TCP에 따라 어떤 포트에 어떤 순서로 정확하게 전달하는지 정해진다.

🧹**포트**란? : 어떤 프로세스가 해당 데이터를 처리하는지에 대한 정보이다. 프로세스는 각자 자신의 Port가 있고, 해당 Port를 통해 데이터를 주고받는다. 
ex) 아파치 톰캣 (스프링 내장 서버) default : 8080 <br><br>

![image](https://github.com/kksshh0612/cs_study/assets/81570533/6430e5bf-5b52-45db-a9c4-e6f09a2bdd27) <br>
TCP는 Application Layer에서 받은 데이터를 일정 단위로 분할해 각각 **TCP 헤더**를 붙여서 **TCP 세그먼트**를 생성한다.  
![image](https://github.com/kksshh0612/cs_study/assets/81570533/5c1742a0-bd4b-4ea7-871d-a5b7d982a360)

### TCP Segment 헤더 구조 
![image](https://github.com/kksshh0612/cs_study/assets/81570533/ab7969aa-7769-4232-bf15-3f43446453d2)
- **Sequence Number** : TCP 통신을 할 때, TCP 세그먼트 여러개가 전송되는데, 이때, Sequence Number는 TCP 세그먼트의 연속된 데이터 번호이다.
- **ACK Number** : 상대 컴퓨터로부터 받아야 하는 다음 TCP 세그먼트 번호이다. 해당 번호 앞 번호까지 처리하였고, 해당 번호 TCP 세그먼트를 전송받아야 함을 표시한다. 참고로, "ACK Number = Sequence Number + 패킷의 데이터 크기" 이다. 
ex)
![image](https://github.com/kksshh0612/cs_study/assets/81570533/41759a97-d2db-4aa2-8c76-39cc0e3f2b08)
해당 예제에서, A가 B에게 패킷을 전송한 후, 응답으로 ACK Number가 1461로 세팅된 패킷이 오지 않으면, 이전에 보낸 패킷 재전송한다. 
즉, B가 A에게 ACK Number : 1461로 세팅한 패킷을 전송하는 의미는 <br>
**"너(A)가 보낸 패킷에 대한 내 대답은 1461이야. 그리고 다음 패킷을 보낼 때 Sequence Number를 1461로 세팅해서 보내줘"**
- **Checksum** : TCP 송신 도중 발생할 수 있는 비트 오류를 검출하기 위해 사용한다. (데이터 무결성 확인)
TCP 체크섬 계산 과정 : <a href="https://securitynewsteam.tistory.com/21">여기</a> <br>

### TCP 전송 제어 
TCP는 원활한 통신을 위해 전송 흐름을 제어하는 기능을 갖고 있다. <br>
전송 제어 방법으로 1. 흐름 제어, 2. 오류 제어, 3. 혼잡 제어 가 있다. <br>

#### 1. 흐름 제어 (Flow Control) 
수신자가 데이터를 처리하는 속도가 다르기 때문에, 송신자는 수신자의 데이터 처리 속도를 파악하고 어느정도 속도로 데이터를 전송할지 제어한다. 만약, 수신자가 데이터를 처리하는 속도가 느리면, 버퍼 용량이 초과하여 데이터가 유실될 위험이 있다. 슬라이딩 윈도우 방식을 사용하고 윈도우 크기를 조절하며 한번에 전송하는 데이터 양을 조절한다.
![image](https://github.com/kksshh0612/cs_study/assets/81570533/589294b6-92ac-4a9f-b2fd-8048cc6b27d4)

#### 2. 오류 제어 (Error Control)
통신 도중 데이터가 유실되거나, 잘못된 데이터가 수신되었을 경우를 처리한다. 두 가지 방법이 있는데,
![image](https://github.com/kksshh0612/cs_study/assets/81570533/0706e621-35d8-42b4-a45a-1151857a589e)
- **Go Bank N** : 오류가 난 데이터 이후부터 다시 전송하도록 한다. 이미 수신한 데이터를 폐기해야 한다. 
- **Selective Repeat** : 오류가 난 데이터만 재전송하도록 하고, 순서가 뒤죽박죽된 버퍼를 정렬한다. (많이 사용)
  ex) 0 1 2 3 5 4 6 -> 재정렬 필요 
![image](https://github.com/kksshh0612/cs_study/assets/81570533/ed0776d1-6dd3-4a66-93bc-6f0d815a0469)

#### 3. 혼잡 제어 (Congestion Control)
네트워크가 불안정해 재전송이 많아져 네트워크 내에 패킷 수가 과도하게 증가하는 상황을 네트워크 혼잡이라 한다. 
TCP에는 혼잡을 회피하는 여러 방법이 있는데, 
1. AIMD (Additive Increse/Multicative Decrease) : 전송에 실패하면 윈도우 크기를 반으로 줄이고, 전송에 성공하면 윈도우 크기를 1 증가시키는 방식으로 혼잡을 제어한다. 윈도우 크기를 조금씩 늘리기 때문에 제대로 된 속도로 통신하기까지 시간이 오래 걸린다. <br>
![image](https://github.com/kksshh0612/cs_study/assets/81570533/6c665183-4710-4550-be55-960e51a38055)
2. Slow Start : AIMD의 단점을 해결하기 위해 등장하였다. 윈도우 크기를 1부터 시작하여 전송에 성공하면 2배씩 크기를 늘려나간다. 대신, 혼잡 현상이 발생하면 윈도우 크기를 1로 떨어뜨린다. 빠르게 네트워크 속도를 끌어올릴 수 있다. <br><br>
위 두 혼잡 회피 방식을 적절히 혼용하여 TCP는 혼잡 제어 정책을 갖고 있다. <br>
**TCP 혼잡 제어 정책**  -> 다음시간에...
- TCP Tahoe : 처음에는 slow start를 사용하다가 임계점에 도달하면 AIMD 방식을 사용한다.
![image](https://github.com/kksshh0612/cs_study/assets/81570533/7bc4ccf5-0ca0-48a2-96ee-e296cf6041b0)
즉, ssthresh 전까지는 윈도우 크기가 2배씩 증가하고, ssthresh 이후에는 윈도우 크기가 1씩 증가한다. 
- TCP Reno : 
   
## UDP 


➕참고자료 
- <a href="https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-TCP-IP-%EC%A0%95%EB%A6%AC-%F0%9F%91%AB%F0%9F%8F%BD-TCP-IP-4%EA%B3%84%EC%B8%B5">Inpa - TCP/IP 4계층</a>
- <a href="https://inpa.tistory.com/entry/WEB-%F0%9F%8C%90-OSI-7%EA%B3%84%EC%B8%B5-%EC%A0%95%EB%A6%AC#tcp/ip_4%EA%B3%84%EC%B8%B5">Inpa - OSI 7계층</a>
- <a href="https://inpa.tistory.com/entry/NW-%F0%9F%8C%90-%EC%95%84%EC%A7%81%EB%8F%84-%EB%AA%A8%ED%98%B8%ED%95%9C-TCP-UDP-%EA%B0%9C%EB%85%90-%E2%9D%93-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EC%9E%90#%F0%9F%95%B9%EF%B8%8F_tcp%EC%9D%98_%EC%A0%84%EC%86%A1_%EC%A0%9C%EC%96%B4_%EA%B8%B0%EB%B2%95">Inpa - TCP, UDP</a>
- <a href="https://kotlinworld.com/94">TCP</a>
- <a href="https://nogan.tistory.com/20">TCP 세그먼트 구</a>
- <a href="https://kotlinworld.com/94">TCP</a>
