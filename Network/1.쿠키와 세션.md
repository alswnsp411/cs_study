# 1. 쿠키와 세션

### 🍪 쿠키
> - 인터넷을 사용하는 유저가 어떤 웹사이트를 방문했을 때 그 사이트가 사용하는 서버를 통해 로컬에 저장되는 작은 데이터이다.
> - 쿠키는 브라우저 내의 저장소에 저장되어 쿠키를 이용해서 서버는 브라우저에 데이터를 저장할 수 있다.
> - 클라이언트와 서버는 쿠키에 데이터를 담아 주고 받을 수 있다.

### 💿 세션
> - 방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 세션이라고 한다.
> - 세션 id를 키 값으로 서버에 클라이언트 관련 데이터를 저장하고, 세션 id만 쿠키에 담아 클라이언트와 서버가 웹사이트에서 사용자를 판단할 수 있다.
<br/>
<br/>

쿠키와 세션은 둘 다 HTTP 통신의 특징인 connectionless와 stateless 문제를 해결하기 위한 방법이다.
> connectionless (비연결성)

서버와 클라이언트의 연결을 유지하지 않는 특성.  
일정 시간 내 요청이 없으면 클라이언트와 서버의 연결을 끊어버린다.  

> stateless (무상태성)

클라이언트에서 서버로 보내는 요청을 독립적으로 처리한다.  
요청을 처리함과 동시에 서버에서는 클라이언트의 상태를 저장하지 않는다.
<br/>
<br/>

(문제😡) 웹서비스를 이용하다 보면 로그인, 장바구니 등 **상태를 저장**해야 하는 경우가 생긴다.  
(해결😄) 쿠키와 세션을 사용하여 상태를 저장한다.

<br/>

### 쿠키와 세션의 차이에 대해 설명해 주세요.
- 쿠키는 브라우저 내의 저장소에 저장되고, 세션은 서버에 저장된다.
- 보안의 측면에서 쿠키는 요청을 수행하며 스니핑될 우려가 있기 때문에 쿠키는 보안에 취약하고 세션은 안전하다.
- 속도의 측면에서는 쿠키는 쿠키 자체에 정보를 가지고 있고, 세션은 서버에 정보를 저장하고 있기때문에 쿠키가 더 빠르다.
- 만료 시점의 측면에서는 쿠키는 브라우저를 닫더라도 지정된 만료 시점이 되기 전까지 유지되고, 세션은 브라우저가 종료되는 시점에서 삭제된다.

<br/>

### 세션 방식의 로그인 과정에 대해 설명해 주세요.
![1 세션 로그인](https://github.com/kksshh0612/cs_study/assets/74577811/ba4c7ac3-2aab-4c83-aa7c-eb81da2f66d2)
1. 클라이언트가 어떤 서버에게 로그인 요청을 한다.
2. 서버에서 사용자 검증 후 유효할 경우
3. 고유한 id 값을 부여한 세션 객체를 생성해 서버 (혹은 세션 저장소)에 저장하고,
4.
5. 세션 id를 포함한 응답을 쿠키에 담아 클라이언트에게 전달한다.
6. 클라이언트가 서버에 작업을 요청할 때마다 쿠키의 요청 헤더에 세션 id를 포함시켜 전달한다.
7. 서버에서는 클라이언트로부터 받은 요청 헤더에서 세션 id를 확인해서 세션 객체를 검증하고
8.
9. 정보가 있으면 요청한 작업에 대해 응답한다.

<br/>

### HTTP의 특성인 Stateless에 대해 설명해 주세요.
HTTP는 기본적으로 무상태(Stateless)를 유지한다.   
서버와 클라이언트의 연결이 해제됨과 동시에 서버는 클라이언트가 이전에 요청한 결과에 대해 잊어버린다.  
따라서 클라이언트는 요청을 할 때마다 서버에 연결해야 한다.  
이러한 특성때문에 서버는 클라이언트의 상태를 보존하지 않게 된다.   
클라이언트는 요청할때마다 서버에 연결해야 하며 요청 시에 모든 정보를 담아 보내야한다. 

🤩장점 
- 서버측에서 상태를 관리해야 하는 부담이 없다.
- 다음 요청을 받는 서버가 이전 요청을 받은 서버일 필요가 없어 서버의 스케일 아웃에 유연하다.  

😭단점
- 클라이언트가 요청 시에 모든 정보를 담아 보내야 해서 그만큼 많은 양의 데이터를 보내야 한다.

<br/>

### Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?
Stateless는 서버가 클라이언트의 상태를 기억하지 않는 특성이다.  
반면에 세션 인증 방식은 서버에 클라이언트의 정보를 담는 방식으로 상태를 유지한다.  
우리가 사용하는 대부분의 웹 서비스를 살펴보면 불가피하게 로그인, 카드 정보 저장 등 보안상 중요한 작업에서 클라이언트의 상태를 유지해야하는 경우가 많다. 그런데 이런 경우들에서 stateless를 지향하기 위해 매 요청마다 필요한 정보를 모두 담아 서버와 연결하는 경우 통신에서 오는 부하와 cost가 더 클 수 있기 때문에 세션 방식을 사용하는 것 같다.

<br/>

### 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?
(문제😡) 스케일 아웃으로 다중 서버 환경이 되면 세션 불일치 문제가 생길 수 있다.   
> 세션 불일치(정합성) 문제
> ![1 세션불일치문제](https://github.com/kksshh0612/cs_study/assets/74577811/1a5cd2e5-40b3-43ce-949b-e5cb762dfc02)
> 다중 서버 환경에서 발생하는 문제로 위 그림과 같은 상황에서 나타난다.
> 특정 클라이언트의 로그인으로 A 서버에 유저 세션 정보를 생성 했다. 그리고 직후에 해당 유저의 작업 요청을 B 서버로 전달한다. 하지만 B 서버에는 유저의 세션 데이터가 존재하지 않는다. 따라서 유저의 요청이 제대로 처리되지 않을 것이다.
<br/>

(해결😄)
> Sticky Session

![1 sticky session](https://github.com/kksshh0612/cs_study/assets/74577811/d81b3ad2-eb17-4cbe-94d9-7219f5eb2ad9)


> Session 클러스터링

 ![1 세션 클러스터링](https://github.com/kksshh0612/cs_study/assets/74577811/f9d888eb-2c09-4096-9868-128480147237)

> primary-secondary session

![1 primary-secondary](https://github.com/kksshh0612/cs_study/assets/74577811/bd2a6e39-bffe-4b71-beab-e5da804ac03e)

> Session Storage

![1 세션 스토리지](https://github.com/kksshh0612/cs_study/assets/74577811/642d49c6-71f1-4589-a9ff-913818796153)

서버 모두가 세션 정보를 공유해야 하므로 Session만을 저장하는 Session 서버를 별도로 만들어 모든 서버에서 해당 Session 서버를 바라보게 하는 방법이 있다. 이렇게 하면 Session 서버에서 오류가 생겼을 때 전체 서버에 영향을 미칠 수 있지만 이를 대비해 Session 서버를 복제해 백업용 Session 서버를 만들어 해결할 수 있다.
