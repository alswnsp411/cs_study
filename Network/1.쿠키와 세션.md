# 1. 쿠키와 세션

### 🍪 쿠키
> - 인터넷을 사용하는 유저가 어떤 웹사이트를 방문했을 때 그 사이트가 사용하는 서버를 통해 로컬에 저장되는 작은 데이터이다.
> - 쿠키는 브라우저 내의 저장소에 저장되어 쿠키를 이용해서 서버는 브라우저에 데이터를 저장할 수 있다.
> - 클라이언트와 서버는 쿠키에 데이터를 담아 주고 받을 수 있다.

### 💿 세션
> - 방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 세션이라고 한다.
> - 세션 id를 키 값으로 서버에 클라이언트 관련 데이터를 저장하고, 세션 id만 쿠키에 담아 클라이언트와 서버가 웹사이트에서 사용자를 판단할 수 있다.
<br/>
<br/>

쿠키와 세션은 둘 다 HTTP 통신의 특징인 connectionless와 stateless 문제를 해결하기 위한 방법이다.
> connectionless (비연결성)

리소스를 아끼기 위해서 서버와 클라이언트의 연결을 유지하지 않는 특성.  
일정 시간 내 요청이 없으면 클라이언트와 서버의 연결을 끊어버린다.  

> stateless (무상태성)

비용을 줄이기 위해서 서버는 요청을 처리함과 동시에 클라이언트의 상태를 저장하지 않는다.  
클라이언트가 요청 시에 모든 정보를 담아 보낸다.
<br/>
<br/>

(문제😡)   
웹서비스를 이용하다 보면 로그인, 장바구니 등 **상태를 저장**해야 하는 경우가 생긴다.  
하지만 위 HTTP 특징 때문에 사용자의 정보 등 상태를 저장할 수 없다.  
          
(해결😄) 쿠키와 세션을 사용하여 상태를 저장한다.

<br/>

### 쿠키와 세션의 차이에 대해 설명해 주세요.
- 쿠키는 브라우저 내의 저장소에 저장되고, 세션은 서버에 저장된다.
- 보안의 측면에서 쿠키는 요청을 수행하며 스니핑될 우려가 있기 때문에 쿠키는 보안에 취약하고 세션은 안전하다.
- 속도의 측면에서는 쿠키는 쿠키 자체에 정보를 가지고 있고, 세션은 서버에 정보를 저장하고 있기때문에 쿠키가 더 빠르다.
- 만료 시점의 측면에서는 쿠키는 브라우저를 닫더라도 지정된 만료 시점이 되기 전까지 유지되고, 세션은 브라우저가 종료되는 시점에서 삭제된다.

<br/>

### 세션 방식의 로그인 과정에 대해 설명해 주세요.
![1 세션 로그인](https://github.com/kksshh0612/cs_study/assets/74577811/ba4c7ac3-2aab-4c83-aa7c-eb81da2f66d2)
1. 클라이언트가 어떤 서버에게 로그인 요청을 한다.
2. 서버에서 사용자 검증 후 유효할 경우
3. 고유한 id 값을 부여한 세션 객체를 생성해 서버 (혹은 세션 저장소)에 저장하고,
4.
5. 세션 id를 포함한 응답을 쿠키에 담아 클라이언트에게 전달한다.
6. 클라이언트가 서버에 작업을 요청할 때마다 쿠키의 요청 헤더에 세션 id를 포함시켜 전달한다.
7. 서버에서는 클라이언트로부터 받은 요청 헤더에서 세션 id를 확인해서 세션 객체를 검증하고
8.
9. 정보가 있으면 요청한 작업에 대해 응답한다.

<br/>

### HTTP의 특성인 Stateless에 대해 설명해 주세요.
서버와 클라이언트의 연결이 해제됨과 동시에 서버가 클라이언트가 이전에 요청한 결과에 대해 잊어버리는 특성이다.  
따라서 클라이언트는 요청을 할 때마다 서버에 연결해야 한다.  
이러한 특성때문에 서버는 클라이언트의 상태를 보존하지 않게 되고, 클라이언트는 요청할때마다 서버에 연결해야 하며 요청 시에 모든 정보를 담아 보내야한다. 

🤩 장점 
- 서버측에서 상태를 관리해야 하는 부담이 없다.
- 다음 요청을 받는 서버가 이전 요청을 받은 서버일 필요가 없어 서버의 스케일 아웃에 유연하다.  

😭 단점
- 클라이언트가 요청 시에 모든 정보를 담아 보내야 해서 그만큼 많은 양의 데이터를 보내야 한다.

<br/>

### Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?
Stateless는 서버가 클라이언트의 상태를 기억하지 않는 특성이다.  
반면에 세션 인증 방식은 서버에 클라이언트의 정보를 담는 방식으로 상태를 유지한다.  
<br />
우리가 사용하는 대부분의 웹 서비스를 살펴보면 불가피하게 로그인, 카드 정보 저장 등 보안상 중요한 작업에서 클라이언트의 상태를 유지해야하는 경우가 많다. 그런데 이런 경우들에서 stateless를 지향하기 위해 매 요청마다 필요한 정보를 모두 담아 서버와 연결하는 경우 통신에서 오는 부하와 cost가 더 클 수 있기 때문에 세션 방식을 사용하는 것 같다.

<br/>

### 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?
(문제😡) 스케일 아웃으로 다중 서버 환경이 되면 **세션 불일치 문제**가 생길 수 있다.   
> 세션 불일치(정합성) 문제  
> ![1 세션불일치문제](https://github.com/kksshh0612/cs_study/assets/74577811/1a5cd2e5-40b3-43ce-949b-e5cb762dfc02)  
> 다중 서버 환경에서 발생하는 문제로 위 그림과 같은 상황에서 나타난다.  
> 특정 클라이언트의 로그인으로 A 서버에 유저 세션 정보를 생성 했다. 그리고 직후에 해당 유저의 작업 요청을 B 서버로 전달한다. 하지만 B 서버에는 유저의 세션 데이터가 존재하지 않는다. 따라서 유저의 요청이 제대로 처리되지 않을 것이다.
<br/>

(해결😄)
<br/>
> Sticky Session

![1 sticky session](https://github.com/kksshh0612/cs_study/assets/74577811/d81b3ad2-eb17-4cbe-94d9-7219f5eb2ad9)  
클라이언트의 요청이 항상 **해당 클라이언트의 세션이 저장된 서버로** 향하는 방식이다.
- 세션 정보가 없는 유저가 요청을 한 경우에는 로드밸런서의 기본 알고리즘대로 요청을 전달한다. 이렇게 세션이 생성되면 앞으로 해당 유저의 요청은 해당 서버로 고정된다.

😭 단점
- 특정 서버에 트래픽이 집중될 위험  
  : 로드 밸런서는 여러 서버에 요청을 적절히 분산해서 부하가 특정 서버에 몰리지 않게 하기 위해 사용한다. 하지만 Sticky Session으로 인해 한 서버에 부하가 몰릴 수 있다.
- 서버에 장애가 발생하는 경우 (가용성 문제)    
  : 해당 서버가 들고 있던 세션 정보가 모두 유실되어, 해당 서버에 Sticky Session을 두고있는 유저는 다시 세션을 생성해야 한다.

<br/>

> Session Clustering (세션 클러스터링)

 ![1 세션 클러스터링](https://github.com/kksshh0612/cs_study/assets/74577811/f9d888eb-2c09-4096-9868-128480147237)  
 - 특정 서버에서 세션이 생성될 때 다른 모든 서버로 세션을 전파하여 **복제**하는 방식이다.  
 - all-to-all 세션 복제 전략
 - 톰캣의 여러 Session Manager 중 DeltaManager를 이용한다.

🤩 장점
 - 서버에 부하가 몰리는 문제, 가용성 문제를 해결할 수 있다.

😭 단점 (대규모 클러스터)
- 비효율적인 메모리 관리  
  : 세션을 모든 서버가 복제하여 들고 있기 때문에 효율적인 메모리 관리를 할 수 없다.
- 많은 네트워크 트래픽 사용
  : 세션을 생성할 때마다 데이터를 전파하고 복제하는 과정에서 Sticky Session 방식에 비해 많은 네트워크 트래픽을 사용한다.  
- 시간차로 인해 발생하는 세션 불일치 문제  
  : 예를들어, A서버에서 생성된 세션이 B서버로는 전파 되었지만, 아직 C 서버로 전파가 되지 않았을 찰나에 클라이언트가 C 서버로 요청할 수도 있다.

<br/>

> primary-secondary session

![1 primary-secondary](https://github.com/kksshh0612/cs_study/assets/74577811/bd2a6e39-bffe-4b71-beab-e5da804ac03e)  
- 세션이 하나의 **Backup node**에만 복제되는 세션 복제 전략이다.
- 클라이언트로부터 요청이 들어오면, 요청을 받은 서버가 세션을 생성하고, primary node로 선정된다.
- 다른 서버들 중 하나가 Backup node(secondary node)로 선정되고 이 서버에 세션 객체의 key-value 전체를 복제한다.
- 이외의 서버(Proxy node)에는 key에 해당하는 세션 아이디와 Primary node, Secondary node의 주소값을 복제한다.
- 그리고 요청이 들어오면, Primary에게 해당 세션 아이디의 데이터를 요청한다.
- 톰캣의 여러 Session Manager 중 BackupManager를 이용한다.

🤩 장점
 - all-to-all 방식보다 메모리 사용량이 적다.
   
😭 단점
- Proxy node 서버에 요청이 들어올 경우 다시 primary 서버에 요청하여 세션 데이터를 받아와야 한다.

<br/>

> 👍 Session Storage

![1 세션 스토리지](https://github.com/kksshh0612/cs_study/assets/74577811/642d49c6-71f1-4589-a9ff-913818796153)  
별도의 세션 저장소에 세션 정보를 저장하고, 서버들이 세션 저장소에서 세션 정보를 읽어오는 방식이다.  

🤩 장점
 - 데이터 불일치 문제 해결 : 세션 저장소를 이용함으로써, 모든 서버가 하나의 세션을 사용한다.
 - 특정 서버에 트래픽이 집중되는 문제가 발생하지 않는다.
 - 별도의 세션 저장소를 사용하기 때문에 특정 서비스에 장애가 발생하더라도 서비스를 제공하는데는 문제가 없다.

😭 단점
- 세션 저장소에 장애가 발생하는 경우  
  : 세션 저장소에 연결된 모든 서버의 세션 이용이 불가능해질 위험
  👍 세션 저장소를 복제하여 만일에 대비한 별도의 세션 저장소를 하나 더 구성해둠으로써 보완할 수 있다.
  
