# 1. 쿠키와 세션

### 🍪 쿠키
> - 인터넷을 사용하는 유저가 어떤 웹사이트를 방문했을 때 그 사이트가 사용하는 서버를 통해 로컬에 저장되는 작은 데이터이다.
> - 쿠키는 브라우저 내의 저장소에 저장되어 쿠키를 이용해서 서버는 브라우저에 데이터를 저장할 수 있다.
> - 클라이언트와 서버는 쿠키에 데이터를 담아 주고 받을 수 있다.
<br/>
✨ 쿠키를 사용해 로그인 하는 경우를 통해 쿠키를 이해해보자!  
<br/>
<br/>

1. 클라이언트가 어떤 서버에게 로그인 요청을 한다.  
2. 서버에서 로그인 성공 시 쿠키를 담아 브라우저에 전달한다.  
3. 브라우저는 해당 쿠키를 브라우저 내의 저장소에 저장해둔다.  
4. 클라이언트가 서버에 작업을 요청할 때마다 해당 쿠키를 보내 어떤 사용자의 요청인지 알려준다.  

이렇게 쿠키를 사용해 로그인을 하는 경우 쿠키에 사용자 정보를 담아 전송하기 때문에 빠르지만, 스니핑의 위험이 있어 보안상 취약하다.

### 💿 세션
> - 방문자가 웹 서버에 접속해 있는 상태를 하나의 단위로 보고 세션이라고 한다.
> - 세션 id를 키 값으로 서버에 클라이언트 관련 데이터를 저장하고, 세션 id만 쿠키에 담아 클라이언트와 서버가 웹사이트에서 사용자를 판단할 수 있다.
<br/>
✨ 세션을 사용해 로그인 하는 경우를 통해 세션을 이해해보자!
<br/>
<br/>

1. 클라이언트가 어떤 서버에게 로그인 요청을 한다.  
2. 서버에서 로그인 성공 시 고유한 id 값을 부여한 세션 객체를 생성해 서버 (혹은 세션 저장소)에 저장하고,  
3. 세션 id를 포함한 응답을 쿠키에 담아 클라이언트에게 전달한다.  
4. 클라이언트가 서버에 작업을 요청할 때마다 쿠키의 요청 헤더에 세션 id를 포함시켜 전달한다.  
5. 서버에서는 클라이언트로부터 받은 요청 헤더에서 세션 id를 확인해서 세션 객체를 검증하고, 정보가 있으면 요청한 작업에 대해 응답한다.  

이렇게 세션을 사용해 로그인을 하는 경우 세션 id를 통해 세션 객체에 접근해 데이터를 찾아오는 데 시간이 걸리지만 보안 상 안전하다.
<br/>
<br/>
<br/>

쿠키와 세션은 둘 다 HTTP 통신의 특징인 connectionless와 stateless 문제를 해결하기 위한 방법이다.
> connectionless (비연결성)

리소스를 아끼기 위해서 서버와 클라이언트의 연결을 유지하지 않는 특성.  
일정 시간 내 요청이 없으면 클라이언트와 서버의 연결을 끊어버린다.  

> stateless (무상태성)

비용을 줄이기 위해서 서버는 요청을 처리함과 동시에 클라이언트의 상태를 저장하지 않는다.  
클라이언트가 요청 시에 모든 정보를 담아 보낸다.
<br/>
<br/>

(문제😡)   
웹서비스를 이용하다 보면 로그인, 장바구니 등 **상태를 저장**해야 하는 경우가 생긴다.  
하지만 위 HTTP 특징 때문에 사용자의 정보 등 상태를 저장할 수 없다.  
          
(해결😄) 쿠키와 세션을 사용하여 상태를 저장한다.

<br/>

---
<br/>

### 쿠키와 세션의 차이에 대해 설명해 주세요.
- 쿠키는 브라우저 내의 저장소에 저장되고, 세션은 서버에 저장된다.
- 보안의 측면에서 쿠키는 요청을 수행하며 스니핑될 우려가 있기 때문에 쿠키는 보안에 취약하고 세션은 안전하다.
- 속도의 측면에서는 쿠키는 쿠키 자체에 정보를 가지고 있고, 세션은 서버에 정보를 저장하고 있기때문에 쿠키가 더 빠르다.
- 만료 시점의 측면에서는 쿠키는 브라우저를 닫더라도 지정된 만료 시점이 되기 전까지 유지되고, 세션은 브라우저가 종료되는 시점에서 삭제된다.

<br/>

### 세션 방식의 로그인 과정에 대해 설명해 주세요.
![1 세션 로그인](https://github.com/kksshh0612/cs_study/assets/74577811/ba4c7ac3-2aab-4c83-aa7c-eb81da2f66d2)
1. 클라이언트가 어떤 서버에게 로그인 요청을 한다.
2. 서버에서 사용자 검증 후 유효할 경우
3. 고유한 id 값을 부여한 세션 객체를 생성해 서버 (혹은 세션 저장소)에 저장하고,
4.
5. 세션 id를 포함한 응답을 쿠키에 담아 클라이언트에게 전달한다.
6. 클라이언트가 서버에 작업을 요청할 때마다 쿠키의 요청 헤더에 세션 id를 포함시켜 전달한다.
7. 서버에서는 클라이언트로부터 받은 요청 헤더에서 세션 id를 확인해서 세션 객체를 검증하고
8.
9. 정보가 있으면 요청한 작업에 대해 응답한다.

<br/>

### HTTP의 특성인 Stateless에 대해 설명해 주세요.
HTTP의 특성인 Stateless는 서버와 클라이언트의 연결이 해제됨과 동시에 서버가 클라이언트가 이전에 요청한 결과에 대해 잊어버리는 특성이다.  
![stateless](https://github.com/kksshh0612/cs_study/assets/74577811/c5de47f4-69fb-4b26-a766-0facf0c157ca)  
출처 : https://blog.naver.com/tgyuu_/222973650140  
<br />

그림을 통해 이해를 해보자면 Stateless는 클라이언트가 http 프로토콜을 통해 같은 서버에 요청을 보내더라도 각 요청마다 다른 점원이 응대하는 것처럼 이전에 요청한 결과에 대해 서버가 전혀 기억하지 못하는 특성이다.  

따라서 클라이언트는 요청을 할 때마다 서버에 연결해야 한다.  
이러한 특성때문에 서버는 클라이언트의 상태를 보존하지 않게 되고, 클라이언트는 요청할때마다 서버에 연결해야 하며 요청 시에 모든 정보를 담아 보내야한다. 

🤩 장점 
- 서버측에서 상태를 관리해야 하는 부담이 없다.
- 다음 요청을 받는 서버가 이전 요청을 받은 서버일 필요가 없어 서버의 스케일 아웃에 유연하다.  

😭 단점
- 클라이언트가 요청 시에 모든 정보를 담아 보내야 해서 그만큼 많은 양의 데이터를 보내야 한다.

<br/>

### Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?
Stateless는 서버가 클라이언트의 상태를 기억하지 않는 특성이다.  
반면에 세션 인증 방식은 서버에 클라이언트의 정보를 담는 방식으로 상태를 유지한다.  
<br />
우리가 사용하는 대부분의 웹 서비스를 살펴보면 불가피하게 로그인, 카드 정보 저장 등 보안상 중요한 작업에서 클라이언트의 상태를 유지해야하는 경우가 많다. 그런데 이런 경우들에서 stateless를 지향하기 위해 매 요청마다 필요한 정보를 모두 담아 서버와 연결하는 경우 통신에서 오는 부하와 cost가 더 클 수 있기 때문에 세션 방식을 사용하는 것 같다.  

따라서, 세션은 http 프로토콜의 Stateless한 특성을 웹 서비스에 적용했을 때의 문제점을 보완하기 위해 만들어진 인증 방법이라고 할 수 있다.

<br/>

### 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?
(문제😡) 스케일 아웃으로 다중 서버 환경이 되면 **세션 불일치 문제**가 생길 수 있다.   
> 세션 불일치(정합성) 문제  
> ![1 세션불일치문제](https://github.com/kksshh0612/cs_study/assets/74577811/1a5cd2e5-40b3-43ce-949b-e5cb762dfc02)  
> 다중 서버 환경에서 발생하는 문제로 위 그림과 같은 상황에서 나타난다.  
> 특정 클라이언트의 로그인으로 서버1에 유저 세션 정보를 생성 했다. 그리고 직후에 해당 유저의 작업 요청을 서버2로 전달한다. 하지만 서버2에는 유저의 세션 데이터가 존재하지 않는다. 따라서 유저의 요청이 제대로 처리되지 않을 것이다.
<br/>

(해결😄)
<br/>
> Sticky Session

![1 sticky session](https://github.com/kksshh0612/cs_study/assets/74577811/d81b3ad2-eb17-4cbe-94d9-7219f5eb2ad9)  
클라이언트의 요청이 항상 **해당 클라이언트의 세션이 저장된 서버로** 향하는 방식이다.
- 세션 정보가 없는 유저가 요청을 한 경우에는 로드밸런서의 기본 알고리즘대로 요청을 전달한다. 이렇게 세션이 생성되면 앞으로 해당 유저의 요청은 해당 서버로 고정된다.

😭 단점
- 특정 서버에 트래픽이 집중될 위험  
  : 로드 밸런서는 여러 서버에 요청을 적절히 분산해서 부하가 특정 서버에 몰리지 않게 하기 위해 사용한다. 하지만 Sticky Session으로 인해 한 서버에 부하가 몰릴 수 있다.
- 서버에 장애가 발생하는 경우 (가용성 문제)    
  : 해당 서버가 들고 있던 세션 정보가 모두 유실되어, 해당 서버에 Sticky Session을 두고있는 유저는 다시 세션을 생성해야 한다.

<br/>

> Session Clustering (세션 클러스터링)

 ![1 세션 클러스터링](https://github.com/kksshh0612/cs_study/assets/74577811/f9d888eb-2c09-4096-9868-128480147237)  
 - 특정 서버에서 세션이 생성될 때 다른 모든 서버로 세션을 전파하여 **복제**하는 방식이다.  
 - all-to-all 세션 복제 전략
 - 톰캣의 여러 Session Manager 중 DeltaManager를 이용한다.

🤩 장점
 - 서버에 부하가 몰리는 문제, 가용성 문제를 해결할 수 있다.

😭 단점 (대규모 클러스터)
- 비효율적인 메모리 관리  
  : 세션을 모든 서버가 복제하여 들고 있기 때문에 효율적인 메모리 관리를 할 수 없다.
- 많은 네트워크 트래픽 사용
  : 세션을 생성할 때마다 데이터를 전파하고 복제하는 과정에서 Sticky Session 방식에 비해 많은 네트워크 트래픽을 사용한다.  
- 시간차로 인해 발생하는 세션 불일치 문제  
  : 예를들어, 서버1에서 생성된 세션이 서버2로는 전파 되었지만, 아직 서버3으로 전파가 되지 않았을 찰나에 클라이언트가 서버3으로 요청할 수도 있다.

<br/>

> primary-secondary session

![1 primary-secondary](https://github.com/kksshh0612/cs_study/assets/74577811/bd2a6e39-bffe-4b71-beab-e5da804ac03e)  
- 세션이 하나의 **Backup node**에만 복제되는 세션 복제 전략이다.
- 클라이언트로부터 요청이 들어오면, 요청을 받은 서버가 세션을 생성하고, primary node로 선정된다.
- 다른 서버들 중 하나가 Backup node(secondary node)로 선정되고 이 서버에 세션 객체의 key-value 전체를 복제한다.
- 이외의 서버(Proxy node)에는 key에 해당하는 세션 아이디와 Primary node, Secondary node의 주소값을 복제한다.
- 그리고 요청이 들어오면, Primary에게 해당 세션 아이디의 데이터를 요청한다.
- 톰캣의 여러 Session Manager 중 BackupManager를 이용한다.

🤩 장점
 - all-to-all 방식보다 메모리 사용량이 적다.
   
😭 단점
- Proxy node 서버에 요청이 들어올 경우 다시 primary 서버에 요청하여 세션 데이터를 받아와야 한다.

<br/>

> 👍 Session Storage

![1 세션 스토리지](https://github.com/kksshh0612/cs_study/assets/74577811/642d49c6-71f1-4589-a9ff-913818796153)  
별도의 세션 저장소에 세션 정보를 저장하고, 서버들이 세션 저장소에서 세션 정보를 읽어오는 방식이다.  

🤩 장점
 - 데이터 불일치 문제 해결 : 세션 저장소를 이용함으로써, 모든 서버가 하나의 세션을 사용한다.
 - 특정 서버에 트래픽이 집중되는 문제가 발생하지 않는다.
 - 별도의 세션 저장소를 사용하기 때문에 특정 서비스에 장애가 발생하더라도 서비스를 제공하는데는 문제가 없다.

😭 단점
- 세션 저장소에 장애가 발생하는 경우  
  : 세션 저장소에 연결된 모든 서버의 세션 이용이 불가능해질 위험
  👍 세션 저장소를 복제하여 만일에 대비한 별도의 세션 저장소를 하나 더 구성해둠으로써 보완할 수 있다.

<br/>
<br/>

## + 추가 질문
### Q. 세션은 서버의 메모리에 저장될 때 어떻게 저장되나요?  

A. 세션은 세션 id로 데이터를 찾아 오는 작업을 빠르게 처리하기 위해 key-value의 데이터 형식으로 저장되고, 다른 데이터에 비해 상대적으로 데이터 크기를 작게 저장한다.  
서버의 메모리(RAM)에 할당된 세션 데이터는 접근하는 속도가 빠른 대신 브라우저를 닫으면 세션이 사라진다.

<br/>

### Q. 세션 스토리지로는 어떤 데이터베이스를 활용하나요?   

A. 데이터베이스는 데이터가 어느 공간에 저장이 되는가에 따라서 In-memory DB와 Disk based DB로 분류된다.
- In-memory DB : 데이터를 메모리에 저장하여 관리
- Disk based DB : 데이터를 디스크에 저장하여 관리

세션 불일치 문제를 해결하기 위해 별도의 세션 스토리지를 구성하는 경우, 세션 스토리지에서는 세션 id를 받아서 세션 객체가 존재하는 지 확인하는 작업을 여러 번 반복해야 한다.  
따라서 세션 스토리지로 접근할 때 마다 Disk I/O 작업을 해야 하는 Disk based DB를 사용하는 것은 성능상 적절하지 않을 수 있지만, 경우에 따라서는 Disk based DB를 사용할 수 있다.  
in-memory DB는 휘발성 메모리이기 때문에 반드시 영속성이 필요하지 않고, 저장공간이 많이 필요하지 않고, 빠르게 데이터를 찾아야 하는 경우 유용하다.  
세션 스토리지로 대표적인 in-memory DB로는 Redis, Memcached가 있다. 둘은 NO-SQL로서, 데이터가 저장될 때 key-value 형식으로 저장되어 세션 스토리지로 적절하다.  
두 저장소는 각자의 장단점을 가지고 있기 때문에 개발자의 판단에 따라 선택할 수 있다.

<br/>

### Q. 브라우저에 쿠키는 최대 몇 개까지 저장되나요?  

A. 쿠키는 브라우저 종료에 상관없이 유효시간 내에 데이터를 유지할 수 있다.  
쿠키에 저장된 정보가 많다면, 매번 요청마다 큰 오버헤드가 발생할 것이다. 이런 이유로 브라우저마다 다르겠지만 일반적으로 쿠키의 데이터는 4kb로 제한이 되어있다.   
또한 브라우저 별 쿠키 제한은 브라우저마다 다른데, chrome 8-58*은 최대 180개까지 만들 수 있다.  

<br/>

### Q. 세션 아이디를 클라이언트에 보낼 때, 쿠키는 클라이언트가 생성하나요 서버가 생성하나요?  

A. 클라이언트가 서버로 http 요청의 body에 인증 정보(유저 이름, 패스워드 등)을 실어 보낸다.  
서버에서는 해당 인증 정보가 유효하면 Session ID를 가진 사용자 세션 객체를 생성한다.  
생성된 Session ID는 응답의 Set-Cookie 헤더에 실어 전송한다.  
이 응답에 담긴 쿠키의 이름은 세션을 관리하는 주체에 따라 다르다. 예를 들어 톰캣은 JSESSIONID, node.js는 connect.sid라는 이름을 사용한다.  
클라이언트는 앞으로 서버에 요청을 보낼 때 세션 아이디를 담은 쿠키를 Cookie 헤더에 실어 전송하여 서버에게 요청의 송신자가 누구인지 알려줄 수 있다.


### Q. 세션은 connecection-oriented하고 stateful한 특성을 갖는건가요?  

A. 세션은 http 프로토콜의 비연결 지향(connectionless), 무상태(stateless)와 같은 특성을 보완하기 위해 도입된 개념이다.   
세션은 서버 측에서 클라이언트에 대한 상태 정보를 유지하고, 클라이언트와 서버 간의 연속성을 제공하여 사용자의 상태를 관리하는 데 사용된다.  
세션에는 주로 로그인한 사용자의 정보를 저장하는데, 이 정보는 영원히 저장되어야 하는 정보느 아니다. 많은 웹 어플리케이션에서 세션을 사용하여 클라이언트와 서버 간에 일정 기간 동안 상태를 유지하고 관리한다.  
따라서, 세션은 일정 기간 동안 connection-oriented하고 stateful한 특성을 갖는다고 할 수 있다.

<br/>

---

<br/>

ref:  
로그인 인증방식 어떤게 좋을까? Session vs JWT : https://80000coding.oopy.io/1f213f10-185c-4b4e-8372-119402fecdd0  
로그인 방식에 대해 알아보자 : https://velog.io/@tsi0521/%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EB%B0%A9%EC%8B%9D%EC%97%90-%EB%8C%80%ED%95%B4-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90  
세션 불일치 문제를 어떻게 해결할 수 있을까 ?  : https://blog.naver.com/baekseongsa/222261086887  
웹 브라우저 쿠키 최대 크기 : https://blog.naver.com/seek316/222639613843  
쿠키와 세션 (feat. HTTP의 Connectionless와 Stateless) : https://mgyo.tistory.com/827  

<br />
